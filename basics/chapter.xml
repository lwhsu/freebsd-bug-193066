<?xml version="1.0" encoding="utf-8"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD Traditional Chinese Project

     $FreeBSD: head/zh_TW.UTF-8/books/handbook/basics/chapter.xml 44974 2014-05-29 16:48:07Z lwhsu $
     Original revision: r46052
-->
<chapter xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0"
  xml:id="basics">
  <!--
  <chapterinfo>
    <authorgroup>
      <author>
	<firstname>Chris</firstname>
	<surname>Shumway</surname>
	<contrib>Rewritten by in Mar 2000</contrib>
      </author>
    </authorgroup>
  </chapterinfo>
  -->
  <title>UNIX 基礎概念</title>

  <sect1 xml:id="basics-synopsis">
    <title>概述</title>

    <para>接下來的這一章將涵蓋 FreeBSD 作業系統的基本指令及功能。
      大部份的內容在 &unix;-like 作業系統中都是相通的。
      如果您對這些內容熟悉的話，可以放心的跳過。
      如果您剛接觸 FreeBSD，那您一定要仔細的讀完這章。</para>

    <para>讀完這章，您將了解：</para>

    <itemizedlist>
      <listitem>
        <para>如何使用 FreeBSD 的<quote>virtual consoles</quote>。</para>
      </listitem>

      <listitem>
	<para>&unix; 檔案權限運作的方式以及 &os; 中檔案的 flags。</para>
      </listitem>

      <listitem>
	<para>預設的 &os; 檔案系統配置。</para>
      </listitem>

      <listitem>
	<para>&os; 的磁碟結構。</para>
      </listitem>

      <listitem>
	<para>如何掛載(mount)、卸載(umount)檔案系統</para>
      </listitem>

      <listitem>
	<para>什麼是processes、daemons 以及 signals 。</para>
      </listitem>

      <listitem>
	<para>什麼是 shell ，以及如何變更您預設的登入環境。</para>
      </listitem>

      <listitem>
	<para>如何使用基本的文字編輯器。</para>
      </listitem>

      <listitem>
	<para>什麼是 devices 和 device nodes 。</para>
      </listitem>

      <listitem>
	<para>&os; 下使用的 binary 格式。</para>
      </listitem>

      <listitem>
	<para>如何閱讀 manual pages 以獲得更多的資訊。</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="consoles">
    <title>Virtual Consoles 和終端機</title>

    <indexterm>
      <primary>virtual consoles</primary>
    </indexterm>
    <indexterm>
      <primary>terminals</primary>
    </indexterm>
    <indexterm>
      <primary>console</primary>
    </indexterm>

    <para>有很多方法可以操作 FreeBSD ，其中一種就是在文字終端機上打字。
      如此使用 FreeBSD 即可輕易的體會到 &unix; 作業系統的威力和彈性。
      這一節描述什麼是<quote>終端機</quote>和 <quote>console</quote>
      ，以及可以如何在 FreeBSD 中運用它們。</para>

    <sect2 xml:id="consoles-intro">
      <title>The Console</title>
      <indexterm><primary>console</primary></indexterm>

      <para>如果您沒有將 FreeBSD 設定成開機時自動進入圖形化模式，系統會在啟動的
	script 跑完之後顯示登入的提示符號。 您將會看到像是這樣的東西：</para>

      <screen>Additional ABI support:.
Local package initialization:.
Additional TCP options:.

Fri Sep 20 13:01:06 EEST 2002

FreeBSD/i386 (pc3.example.org) (ttyv0)

login:</screen>

      <para>這個訊息在您的系統上會有些許的不同，但是應該會看到類似的東西。
	    我們感興趣的是最後兩行，最後兩行是：</para>

      <programlisting>FreeBSD/i386 (pc3.example.org) (ttyv0)</programlisting>

      <para>這行包含了剛開機完系統的資訊。 您看到的是在 Intel 或相容處理器的
	x86 架構上執行的 <quote>FreeBSD</quote>的 console<footnote>
          <para>這就是 <literal>i386</literal> 的意義。 注意即使您不是在
	    Intel 的 386 處理器上執行 FreeBSD ，一樣是<literal>i386</literal>。
            這不是指你的處理器的型號，這裡顯示的是你處理器的<quote>架構</quote>
	    </para>
        </footnote>。 這台機器的名字(每台 &unix; 機器都有一個名字)是
        <systemitem>pc3.example.org</systemitem>，而您現在看到的是它的系統
        console&mdash; <filename>ttyv0</filename>終端機。</para>

      <para>最後的一行應該都會是：</para>

      <programlisting>login:</programlisting>

      <para>這是您應該要輸入您的<quote>帳號名稱</quote>的地方。
        下一小節將告訴您如何登入 FreeBSD。</para>
    </sect2>

    <sect2 xml:id="consoles-login">
      <title>登入 FreeBSD</title>

      <para>FreeBSD 是一個 multiuser、multiprocessing 的系統。
	這是一個正式的名稱，指的是在單一機器上可以同時被不同人使用，
	但同時可以執行很多程式的系統。</para>

      <para>每一種多使用者系統都需要可以分辨不同<quote>使用者</quote>的方法。
        在 FreeBSD (以及所有的 &unix;-like 作業系統)
        中，所有的使用者在執行程式之前必須先<quote>登入</quote>系統。
	每個使用者都有一組獨特的帳號名稱
        (<quote>username</quote>)及密碼(<quote>password</quote>)。
        FreeBSD 在允許使用者執行程式前將會先問這兩個問題。</para>

      <indexterm><primary>startup scripts</primary></indexterm>
      <para>在 FreeBSD 開機並跑完啟動的 script 之後<footnote>
        <para>這些啟動的 script 是在開機的時候 FreeBSD 會自動執行的程式。
	  他們主要的功能是將所有該執行的東西設定好，
	  並將您設定成背景執行的服務啟動。</para>
      </footnote>，它將會印出提示字元要求您輸入正確的帳號名稱：</para>

      <screen>login:</screen>

      <para>在這個範例裡，我們假設您的帳號是<systemitem class="username">john</systemitem>。
        在提示字元處輸入 <literal>john</literal> 並按下 <keycap>Enter</keycap>
	。  接著您應該會看到另一個提示字元要您輸入<quote>密碼</quote>：</para>

      <screen>login: <userinput>john</userinput>
Password:</screen>

      <para>輸入 <systemitem class="username">john</systemitem> 的密碼，再按下
	<keycap>Enter</keycap>。  輸入的密碼
	<emphasis>不會顯示在螢幕上</emphasis>。
	您不需要為此擔心，這樣做是為了安全上的問題。</para>

      <para>如果您輸入了正確的密碼，您應該已經登入 FreeBSD。
	現在就可以嘗試所有可用的指令了。</para>

      <para>您應該會看到<acronym>MOTD</acronym>
        (即今日訊息、Messages Of The Day)，後面接著命令提示字元
        (一個 <literal>#</literal>,<literal>$</literal>, 或是
	<literal>%</literal> 字元)。 這就表示您已經成功登入
	FreeBSD 了。</para>
    </sect2>

    <sect2 xml:id="consoles-virtual">
      <title>多重 Console</title>

      <para>在一個 Console 下執行 &unix; 當然是沒有問題，然而 FreeBSD
	是可以同時執行很多程式的。  像 FreeBSD
	這樣可以同時執行一大堆程式的作業系統，只有一個
        console 可以輸入指令實在是有點浪費。  因此
	<quote>virtual consoles</quote> 就顯得相當好用。</para>

      <para>可以設定讓 FreeBSD 同時有很多 virtual console，
	用幾個按鍵的組合就可以從一個 virtual console 跳到別的 virtual console
	。  每一個 console 都有自已不同的輸出頻道，當從某一個 virtual console
	切換到下一個的時候，FreeBSD 會自動處理鍵盤輸入及螢幕輸出。</para>

      <para>FreeBSD 保留了特別的按鍵組合來切換 console <footnote>
        <para>在 &man.syscons.4;、&man.atkbd.4;、&man.vidcontrol.1;、以及
          &man.kbdcontrol.1;等 manual page 中，對於 FreeBSD 的 console
          及鍵盤驅動程式有詳細的技術說明。  我們在這裡不討論細節，
	  有興趣的讀者隨時可以在 manual pages
	  中查到關於運作方式的更詳細且完整的解釋。</para></footnote>。
	您可以用 <keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>、
        <keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>、到
        <keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	來切換 FreeBSD 的不同 console。</para>

      <para>當您從一個 console 切換到下一個的時候，FreeBSD
	會處理螢幕輸出的儲存及回復。
	這就<quote>好像</quote>有很多<quote>虛擬</quote>的螢幕和鍵盤，
	可以讓您輸入指令到 FreeBSD 執行。  在某一個 console
	上執行的程式並不會因為切到別的 console 而停止執行，切換到另一個
	console 時，它們仍會繼續執行。</para>
    </sect2>

    <sect2 xml:id="consoles-ttys">
      <title><filename>/etc/ttys</filename> 檔</title>

      <para>FreeBSD 預設的虛擬 console 總共有 8 個，
        但這並非硬性規定，您可輕鬆設定這些虛擬 console 的數量增減。
	有關虛擬 console 的編號跟設定都在
	<filename>/etc/ttys</filename> 這檔案內設定。</para>

      <para>可以用 <filename>/etc/ttys</filename> 檔案來設定
	FreeBSD 的虛擬 console。 檔案內每行非註解文字(該行開頭沒有
	<literal>#</literal> 這字)都是設定終端機或虛擬 console。
	FreeBSD 預設有 9 個虛擬 console 但只啟動 8 個，也就是以下以
	<literal>ttyv</literal>	開頭的那幾行設定。</para>

      <programlisting># name  getty                           type    status          comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>有關各欄位的設定以及其他選項，請參閱 &man.ttys.5; 說明。</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Single User 模式的 Console</title>

      <para>有關 <quote>single user 模式</quote> 的介紹在
	<xref linkend="boot-singleuser"/>
        這邊有詳盡介紹。  在 single user 模式時，能夠使用的 console
	只有一個，並無虛擬 console 可用。  而 single user 模式相關設定值可以在
	<filename>/etc/ttys</filename> 檔做調整。  下面以
	<literal>console</literal> 開頭的那行，就是了：</para>

      <programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off secure</programlisting>

      <note>
	<para>在 <literal>console</literal> 那行前面的註解有提到，可以把那行的
	  <literal>secure</literal> 改為 <literal>insecure</literal>，
	  如此一來，即使 FreeBSD 進入 single user 模式，
	  仍會要求您輸入 <systemitem class="username">root</systemitem> 的密碼。</para>

	<para><emphasis>請審慎考慮是否要改為
	  <literal>insecure</literal></emphasis>。 因為萬一忘記
	  <systemitem class="username">root</systemitem> 密碼的話，若要登入 single user
	  模式就有些麻煩了。儘管還有其他方式可以登入，但對不熟 FreeBSD
	  開機程序的人而言，就會相當棘手。</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>更改 console 的顯示畫面</title>

      <para>FreeBSD console 預設顯示大小可以調整為 1024x768、1280x1024
	或其他顯示卡與螢幕有支援的解析度大小。  要切換顯示大小，必須要重新編譯
	kernel 並加入下面這兩項設定：</para>

      <programlisting>options VESA
options SC_PIXEL_MODE</programlisting>

      <para>一旦 kernel 有加入這兩項並重新編譯完畢，就可以用 &man.vidcontrol.1;
	來偵測目前所支援的模式有哪些。  若要查看支援的模式，可以打：</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>該指令會顯示該機器所支援的顯示模式清單。  然後可以在
	<systemitem class="username">root</systemitem> console 內透過 &man.vidcontrol.1; 指令，
	來更改顯示模式：</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>若對新的顯示模式覺得還不錯，可以在 <filename>/etc/rc.conf</filename>
	設定之，以讓每次重開機後會自動生效。  以上面這情況為例，就是：</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="users-synopsis">
    <title>Users and Basic Account Management</title>

    <para>&os; allows multiple users to use the computer at the same
      time.  While only one user can sit in front of the screen and
      use the keyboard at any one time, any number of users can log
      in to the system through the network.  To use the system, each
      user should have their own user account.</para>

    <para>This chapter describes:</para>

    <itemizedlist>
      <listitem>
	<para>The different types of user accounts on a
	  &os; system.</para>
      </listitem>

      <listitem>
	<para>How to add, remove, and modify user accounts.</para>
      </listitem>

      <listitem>
	<para>How to set limits to control the
	  resources that users and
	  groups are allowed to access.</para>
      </listitem>

      <listitem>
	<para>How to create groups and add users as members of a
	  group.</para>
      </listitem>
    </itemizedlist>

    <sect2 xml:id="users-introduction">
      <title>Account Types</title>

      <para>Since all access to the &os; system is achieved using
	accounts and all processes are run by users, user and account
	management is important.</para>

      <para>There are three main types of accounts: system accounts,
	user accounts, and the superuser account.</para>

      <sect3 xml:id="users-system">
	<title>System Accounts</title>

	<indexterm>
	  <primary>accounts</primary>
	  <secondary>system</secondary>
	</indexterm>

	<para>System accounts are used to run services such as DNS,
	  mail, and web servers.  The reason for this is security; if
	  all services ran as the superuser, they could act without
	  restriction.</para>

	<indexterm>
	  <primary>accounts</primary>
	  <secondary><systemitem
	      class="username">daemon</systemitem></secondary>
	</indexterm>
	<indexterm>
	  <primary>accounts</primary>
	  <secondary><systemitem
	      class="username">operator</systemitem></secondary>
	</indexterm>

	<para>Examples of system accounts are
	  <systemitem class="username">daemon</systemitem>,
	  <systemitem class="username">operator</systemitem>,
	  <systemitem class="username">bind</systemitem>,
	  <systemitem class="username">news</systemitem>, and
	  <systemitem class="username">www</systemitem>.</para>

	<indexterm>
	  <primary>accounts</primary>
	  <secondary><systemitem
	      class="username">nobody</systemitem></secondary>
	</indexterm>

	<para><systemitem class="username">nobody</systemitem> is the
	  generic unprivileged system account.  However, the more
	  services that use
	  <systemitem class="username">nobody</systemitem>, the more
	  files and processes that user will become associated with,
	  and hence the more privileged that user becomes.</para>
      </sect3>

      <sect3 xml:id="users-user">
	<title>User Accounts</title>

	<indexterm>
	  <primary>accounts</primary>
	  <secondary>user</secondary>
	</indexterm>

	<para>User accounts are assigned to real people and are used
	  to log in and use the system.  Every person accessing the
	  system should have a unique user account.  This allows the
	  administrator to find out who is doing what and prevents
	  users from clobbering the settings of other users.</para>

	<para>Each user can set up their own environment to
	  accommodate their use of the system, by configuring their
	  default shell, editor, key bindings, and language
	  settings.</para>

	<para>Every user account on a &os; system has certain
	  information associated with it:</para>

	<variablelist>
	  <varlistentry>
	    <term>User name</term>

	    <listitem>
	      <para>The user name is typed at the
		<prompt>login:</prompt> prompt.  Each user must have
		a unique user name.  There are a number of rules for
		creating valid user names which are documented in
		&man.passwd.5;.  It is recommended to use user names
		that consist of eight or fewer, all lower case
		characters in order to maintain backwards
		compatibility with applications.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Password</term>

	    <listitem>
	      <para>Each account has an associated password.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>User ID (<acronym>UID</acronym>)</term>

	    <listitem>
	      <para>The User ID (<acronym>UID</acronym>) is a number
		used to uniquely identify the user to the &os; system.
		Commands that allow a user name to be specified will
		first convert it to the <acronym>UID</acronym>.  It is
		recommended to use a UID less than 65535, since higher
		values may cause compatibility issues with some
		software.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Group ID (<acronym>GID</acronym>)</term>

	    <listitem>
	      <para>The Group ID (<acronym>GID</acronym>) is a number
		used to uniquely identify the primary group that the
		user belongs to.  Groups are a mechanism for
		controlling access to resources based on a user's
		<acronym>GID</acronym> rather than their
		<acronym>UID</acronym>.  This can significantly reduce
		the size of some configuration files and allows users
		to be members of more than one group.  It is
		recommended to use a GID of 65535 or lower as higher
		GIDs may break some software.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Login class</term>

	    <listitem>
	      <para>Login classes are an extension to the group
		mechanism that provide additional flexibility when
		tailoring the system to different users.  Login
		classes are discussed further in
		<xref linkend="users-limiting"/>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Password change time</term>

	    <listitem>
	      <para>By default, passwords do not expire.  However,
		password expiration can be enabled on a per-user
		basis, forcing some or all users to change their
		passwords after a certain amount of time has
		elapsed.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Account expiry time</term>

	    <listitem>
	      <para>By default, &os; does not expire accounts.  When
		creating accounts that need a limited lifespan, such
		as student accounts in a school, specify the account
		expiry date using &man.pw.8;.  After the expiry time
		has elapsed, the account cannot be used to log in to
		the system, although the account's directories and
		files will remain.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>User's full name</term>

	    <listitem>
	      <para>The user name uniquely identifies the account to
		&os;, but does not necessarily reflect the user's real
		name.  Similar to a comment, this information can
		contain spaces, uppercase characters, and be more
		than 8 characters long.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Home directory</term>

	    <listitem>
	      <para>The home directory is the full path to a directory
		on the system.  This is the user's starting directory
		when the user logs in.  A common convention is to put
		all user home directories under <filename
		  class="directory"><replaceable>/home/username</replaceable></filename>
		or <filename
		  class="directory"><replaceable>/usr/home/username</replaceable></filename>.
		Each user stores their personal files and
		subdirectories in their own home directory.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>User shell</term>

	    <listitem>
	      <para>The shell provides the user's default environment
		for interacting with the system.  There are many
		different kinds of shells and experienced users will
		have their own preferences, which can be reflected in
		their account settings.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3 xml:id="users-superuser">
	<title>The Superuser Account</title>

	<indexterm>
	  <primary>accounts</primary>
	  <secondary>superuser (root)</secondary>
	</indexterm>

	<para>The superuser account, usually called
	  <systemitem class="username">root</systemitem>, is used to
	  manage the system with no limitations on privileges.  For
	  this reason, it should not be used for day-to-day tasks like
	  sending and receiving mail, general exploration of the
	  system, or programming.</para>

	<para>The superuser, unlike other user accounts, can operate
	  without limits, and misuse of the superuser account may
	  result in spectacular disasters.  User accounts are unable
	  to destroy the operating system by mistake, so it is
	  recommended to login as a user account and to only become
	  the superuser when a command requires extra
	  privilege.</para>

	<para>Always double and triple-check any commands issued as
	  the superuser, since an extra space or missing character can
	  mean irreparable data loss.</para>

	<para>There are several ways to gain superuser privilege.
	  While one can log in as
	  <systemitem class="username">root</systemitem>, this is
	  highly discouraged.</para>

	<para>Instead, use &man.su.1; to become the superuser.  If
	  <literal>-</literal> is specified when running this command,
	  the user will also inherit the root user's environment.  The
	  user running this command must be in the
	  <systemitem class="groupname">wheel</systemitem> group or
	  else the command will fail.  The user must also know the
	  password for the
	  <systemitem class="username">root</systemitem> user
	  account.</para>

	<para>In this example, the user only becomes superuser in
	  order to run <command>make install</command> as this step
	  requires superuser privilege.  Once the command completes,
	  the user types <command>exit</command> to leave the
	  superuser account and return to the privilege of their user
	  account.</para>

	<example>
	  <title>Install a Program As the Superuser</title>

	  <screen>&prompt.user; <userinput>configure</userinput>
&prompt.user; <userinput>make</userinput>
&prompt.user; <userinput>su -</userinput>
Password:
&prompt.root; <userinput>make install</userinput>
&prompt.root; <userinput>exit</userinput>
&prompt.user;</screen>
	</example>

	<para>The built-in &man.su.1; framework works well for single
	  systems or small networks with just one system
	  administrator.  An alternative is to install the
	  <package>security/sudo</package> package or port.  This
	  software provides activity logging and allows the
	  administrator to configure which users can run which
	  commands as the superuser.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="users-modifying">
      <title>Managing Accounts</title>

      <indexterm>
	<primary>accounts</primary>
	<secondary>modifying</secondary>
      </indexterm>

      <para>&os; provides a variety of different commands to manage
	user accounts.  The most common commands are summarized in
	<xref linkend="users-modifying-utilities"/>, followed by some
	examples of their usage.  See the manual page for each utility
	for more details and usage examples.</para>

      <table frame="none" pgwide="1"
	xml:id="users-modifying-utilities">
	<title>Utilities for Managing User Accounts</title>

	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="2*"/>

	  <thead>
	    <row>
	      <entry>Command</entry>
	      <entry>Summary</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>&man.adduser.8;</entry>
	      <entry>The recommended command-line application for
		adding new users.</entry>
	    </row>

	    <row>
	      <entry>&man.rmuser.8;</entry>
	      <entry>The recommended command-line application for
		removing users.</entry>
	    </row>

	    <row>
	      <entry>&man.chpass.1;</entry>
	      <entry>A flexible tool for changing user database
		information.</entry>
	    </row>

	    <row>
	      <entry>&man.passwd.1;</entry>
	      <entry>The command-line tool to change user
		passwords.</entry>
	    </row>

	    <row>
	      <entry>&man.pw.8;</entry>
	      <entry>A powerful and flexible tool for modifying all
		aspects of user accounts.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <sect3 xml:id="users-adduser">
	<title><command>adduser</command></title>

	<indexterm>
	  <primary>accounts</primary>
	  <secondary>adding</secondary>
	</indexterm>
	<indexterm>
	  <primary><command>adduser</command></primary>
	</indexterm>
	<indexterm>
	  <primary><filename>/usr/share/skel</filename></primary>
	</indexterm>
	<indexterm>
	  <primary>skeleton directory</primary>
	</indexterm>

	<para>The recommended program for adding new users is
	  &man.adduser.8;.  When a new user is added, this program
	  automatically updates <filename>/etc/passwd</filename> and
	  <filename>/etc/group</filename>.  It also creates a home
	  directory for the new user, copies in the default
	  configuration files from
	  <filename>/usr/share/skel</filename>, and can optionally
	  mail the new user a welcome message.  This utility must be
	  run as the superuser.</para>

	<para>The &man.adduser.8; utility is interactive and walks
	  through the steps for creating a new user account.  As seen
	  in <xref linkend="users-modifying-adduser"/>, either input
	  the required information or press <keycap>Return</keycap>
	  to accept the default value shown in square brackets.
	  In this example, the user has been invited into the
	  <systemitem class="groupname">wheel</systemitem> group,
	  allowing them to become the superuser with &man.su.1;.
	  When finished, the utility will prompt to either
	  create another user or to exit.</para>

	<example xml:id="users-modifying-adduser">
	  <title>Adding a User on &os;</title>

	  <screen>&prompt.root; <userinput>adduser</userinput>
Username: <userinput>jru</userinput>
Full name: <userinput>J. Random User</userinput>
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: <userinput>wheel</userinput>
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: <userinput>zsh</userinput>
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): <userinput>yes</userinput>
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): <userinput>no</userinput>
Goodbye!
&prompt.root;</screen>
	</example>

	<note>
	  <para>Since the password is not echoed when typed, be
	    careful to not mistype the password when creating the user
	    account.</para>
	</note>
      </sect3>

      <sect3 xml:id="users-rmuser">
	<title><command>rmuser</command></title>

	<indexterm>
	  <primary><command>rmuser</command></primary>
	</indexterm>
	<indexterm>
	  <primary>accounts</primary>
	  <secondary>removing</secondary>
	</indexterm>

	<para>To completely remove a user from the system, run
	  &man.rmuser.8; as the superuser.  This command performs the
	  following steps:</para>

	<procedure>
	  <step>
	    <para>Removes the user's &man.crontab.1; entry, if one
	      exists.</para>
	  </step>

	  <step>
	    <para>Removes any &man.at.1; jobs belonging to the
	      user.</para>
	  </step>

	  <step>
	    <para>Kills all processes owned by the user.</para>
	  </step>

	  <step>
	    <para>Removes the user from the system's local password
	      file.</para>
	  </step>

	  <step>
	    <para>Optionally removes the user's home directory, if it
	      is owned by the user.</para>
	  </step>

	  <step>
	    <para>Removes the incoming mail files belonging to the
	      user from <filename>/var/mail</filename>.</para>
	  </step>

	  <step>
	    <para>Removes all files owned by the user from temporary
	      file storage areas such as
	      <filename>/tmp</filename>.</para>
	  </step>

	  <step>
	    <para>Finally, removes the username from all groups to
	      which it belongs in <filename>/etc/group</filename>.  If
	      a group becomes empty and the group name is the same as
	      the username, the group is removed.  This complements
	      the per-user unique groups created by
	      &man.adduser.8;.</para>
	  </step>
	</procedure>

	<para>&man.rmuser.8; cannot be used to remove superuser
	  accounts since that is almost always an indication of
	  massive destruction.</para>

	<para>By default, an interactive mode is used, as shown
	  in the following example.</para>

	<example>
	  <title><command>rmuser</command> Interactive Account
	    Removal</title>

	  <screen>&prompt.root; <userinput>rmuser jru</userinput>
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? <userinput>y</userinput>
Remove user's home directory (/home/jru)? <userinput>y</userinput>
Removing user (jru): mailspool home passwd.
&prompt.root;</screen>
	</example>
      </sect3>

      <sect3 xml:id="users-chpass">
	<title><command>chpass</command></title>

	<indexterm>
	  <primary><command>chpass</command></primary>
	</indexterm>

	<para>Any user can use &man.chpass.1; to change their default
	  shell and personal information associated with their user
	  account.  The superuser can use this utility to change
	  additional account information for any user.</para>

	<para>When passed no options, aside from an optional username,
	  &man.chpass.1; displays an editor containing user
	  information.  When the user exits from the editor, the user
	  database is updated with the new information.</para>

	<note>
	  <para>This utility will prompt for the user's password when
	    exiting the editor, unless the utility is run as the
	    superuser.</para>
	</note>

	<para>In <xref linkend="users-modifying-chpass-su"/>, the
	  superuser has typed <command>chpass jru</command> and is
	  now viewing the fields that can be changed for this user.
	  If <systemitem class="username">jru</systemitem> runs this
	  command instead, only the last six fields will be displayed
	  and available for editing.  This is shown in
	  <xref linkend="users-modifying-chpass-ru"/>.</para>

	<example xml:id="users-modifying-chpass-su">
	  <title>Using <command>chpass</command> as
	    Superuser</title>

	  <screen>#Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
	</example>

	<example xml:id="users-modifying-chpass-ru">
	  <title>Using <command>chpass</command> as Regular
	    User</title>

	  <screen>#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</screen>
	</example>

	<note>
	  <para>The commands &man.chfn.1; and &man.chsh.1; are links
	    to &man.chpass.1;, as are &man.ypchpass.1;,
	    &man.ypchfn.1;, and &man.ypchsh.1;.  Since
	    <acronym>NIS</acronym> support is automatic, specifying
	    the <literal>yp</literal> before the command is not
	    necessary.  How to configure NIS is covered in <xref
	      linkend="network-servers"/>.</para>
	</note>
      </sect3>

      <sect3 xml:id="users-passwd">
	<title><command>passwd</command></title>

	<indexterm>
	  <primary><command>passwd</command></primary>
	</indexterm>
	<indexterm>
	  <primary>accounts</primary>
	  <secondary>changing password</secondary>
	</indexterm>

	<para>Any user can easily change their password using
	  &man.passwd.1;.  To prevent accidental or unauthorized
	  changes, this command will prompt for the user's original
	  password before a new password can be set:</para>

	<example>
	  <title>Changing Your Password</title>

	  <screen>&prompt.user; <userinput>passwd</userinput>
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
	</example>

	<para>The superuser can change any user's password by
	  specifying the username when running &man.passwd.1;.  When
	  this utility is run as the superuser, it will not prompt for
	  the user's current password.  This allows the password to be
	  changed when a user cannot remember the original
	  password.</para>

	<example>
	  <title>Changing Another User's Password as the
	    Superuser</title>

	  <screen>&prompt.root; <userinput>passwd jru</userinput>
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</screen>
	</example>

	<note>
	  <para>As with &man.chpass.1;, &man.yppasswd.1; is a link to
	    &man.passwd.1;, so <acronym>NIS</acronym> works with
	    either command.</para>
	</note>
      </sect3>

      <sect3 xml:id="users-pw">
	<title><command>pw</command></title>

	<indexterm>
	  <primary><command>pw</command></primary>
	</indexterm>

	<para>The &man.pw.8; utility can create, remove,
	  modify, and display users and groups.  It functions as a
	  front end to the system user and group files.  &man.pw.8;
	  has a very powerful set of command line options that make it
	  suitable for use in shell scripts, but new users may find it
	  more complicated than the other commands presented in this
	  section.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="users-groups">
      <title>Managing Groups</title>

      <indexterm>
	<primary>groups</primary>
      </indexterm>
      <indexterm>
	<primary><filename>/etc/groups</filename></primary>
      </indexterm>
      <indexterm>
	<primary>accounts</primary>
	<secondary>groups</secondary>
      </indexterm>

      <para>A group is a list of users.  A group is identified by its
	group name and <acronym>GID</acronym>.  In &os;, the kernel
	uses the <acronym>UID</acronym> of a process, and the list of
	groups it belongs to, to determine what the process is allowed
	to do.  Most of the time, the <acronym>GID</acronym> of a user
	or process usually means the first group in the list.</para>

      <para>The group name to <acronym>GID</acronym> mapping is listed
	in <filename>/etc/group</filename>.  This is a plain text file
	with four colon-delimited fields.  The first field is the
	group name, the second is the encrypted password, the third
	the <acronym>GID</acronym>, and the fourth the comma-delimited
	list of members.  For a more complete description of the
	syntax, refer to &man.group.5;.</para>

      <para>The superuser can modify <filename>/etc/group</filename>
	using a text editor.  Alternatively, &man.pw.8; can be used to
	add and edit groups.  For example, to add a group called
	<systemitem class="groupname">teamtwo</systemitem> and then
	confirm that it exists:</para>

      <example>
	<title>Adding a Group Using &man.pw.8;</title>

	<screen>&prompt.root; <userinput>pw groupadd teamtwo</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:</screen>
      </example>

      <para>In this example, <literal>1100</literal> is the
	<acronym>GID</acronym> of
	<systemitem class="groupname">teamtwo</systemitem>.  Right
	now, <systemitem class="groupname">teamtwo</systemitem> has no
	members.  This command will add
	<systemitem class="username">jru</systemitem> as a member of
	<systemitem class="groupname">teamtwo</systemitem>.</para>

      <example>
	<title>Adding User Accounts to a New Group Using
	  &man.pw.8;</title>

	<screen>&prompt.root; <userinput>pw groupmod teamtwo -M jru</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru</screen>
      </example>

      <para>The argument to <option>-M</option> is a comma-delimited
	list of users to be added to a new (empty) group or to replace
	the members of an existing group.  To the user, this group
	membership is different from (and in addition to) the user's
	primary group listed in the password file.  This means that
	the user will not show up as a member when using
	<option>groupshow</option> with &man.pw.8;, but will show up
	when the information is queried via &man.id.1; or a similar
	tool.  When &man.pw.8; is used to add a user to a group, it
	only manipulates <filename>/etc/group</filename> and does not
	attempt to read additional data from
	<filename>/etc/passwd</filename>.</para>

      <example>
	<title>Adding a New Member to a Group Using &man.pw.8;</title>

	<screen>&prompt.root; <userinput>pw groupmod teamtwo -m db</userinput>
&prompt.root; <userinput>pw groupshow teamtwo</userinput>
teamtwo:*:1100:jru,db</screen>
      </example>

      <para>In this example, the argument to <option>-m</option> is a
	comma-delimited list of users who are to be added to the
	group.  Unlike the previous example, these users are appended
	to the group and do not replace existing users in the
	group.</para>

      <example>
	<title>Using &man.id.1; to Determine Group Membership</title>

	<screen>&prompt.user; <userinput>id jru</userinput>
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</screen>
      </example>

      <para>In this example,
	<systemitem class="username">jru</systemitem> is a member of
	the groups <systemitem class="groupname">jru</systemitem> and
	<systemitem class="groupname">teamtwo</systemitem>.</para>

      <para>For more information about this command and the format of
	<filename>/etc/group</filename>, refer to &man.pw.8; and
	&man.group.5;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>權限</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>FreeBSD 源自於 BSD &unix;，繼承了幾個重要的 &unix; 概念。
      首先也最明顯，它是一款 multi-user 作業系統。 它可以同時處理多人多工，
      負責徹底的分享與管理來自每位使用者對硬碟裝置、週邊設備、記憶體及
      CPU 時間的要求。</para>

    <para>也因為系統能夠支援多使用者，
      所以系統管理的一切都有權限來決定誰可以讀取、寫入或執行資源。
      這些權限分別使用三組八進位的數字儲存，一組代表檔案的所有者，
      一組代表檔案所屬的群組，而最後一組則代表其他所有人。
      表示這些數字的方式如下:</para>

    <indexterm><primary>permissions</primary></indexterm>
    <indexterm>
      <primary>file permissions</primary>
    </indexterm>
    <informaltable frame="none" pgwide="1">
      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>值</entry>
	    <entry>權限</entry>
	    <entry>目錄顯示</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>不可讀取, 不可寫入, 不可執行</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>不可讀取, 不可寫入, 可執行</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>不可讀取, 可寫入, 不可執行</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>不可讀取, 可寫入, 可執行</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>可讀取, 不可寫入, 不可執行</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>可讀取, 不可寫入, 可執行</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>可讀取, 可寫入, 不可執行</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>可讀取, 可寫入, 可執行</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
    <indexterm>
      <primary><command>ls</command></primary>
    </indexterm>
    <indexterm><primary>directories</primary></indexterm>

    <para>使用 &man.ls.1; 指令時，可以加上 <option>-l</option> 參數，
      來檢視詳細的目錄清單。
      清單中欄位的資訊包含檔案對所有者、群組及其他人的權限。
      在任一個目錄底下執行 <command>ls -l</command>，會顯示如下的結果:
      </para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
...</screen>

    <para>在這裡告所您該如何區分 <command>ls -l</command>
      第一欄當中的資訊:</para>

    <screen>-rw-r--r--</screen>

    <para>第一個 (最左邊) 的字元用來表示這個檔案的類型為何，
      除標準檔案以外，尚有目錄、特殊字元裝置 (Special character device)、
      Socket 及其他特殊虛擬檔案裝置 (Special pseudo-file device)，
      在此例當中，<literal>-</literal> 表示該檔案為一個標準的檔案。
      範例中接下來的三個字元中，<literal>rw-</literal>
      代表所有者對檔案擁有的權限。 再接下來的三個字元，
      <literal>r--</literal> 則代表群組對檔案擁有的權限，
      最後三個字元，<literal>r--</literal> 則代表其他人對檔案擁有的權限。
      破折號 (-) 表示沒有權限，範例中的這個檔案的權限，
      只允許所有者讀取、寫入檔案，群組以及其他人僅能讀取檔案。
      根據以上的表格，此種權限的檔案可以使用 <literal>644</literal> 來表示，
      每組數字分別代表檔案的三種權限。</para>

    <para>以上是不錯的方式，但系統該如何控制裝置的權限？ 實際上 FreeBSD
      對大多的硬碟裝置就如同檔案，程式可以開啟、讀取以及寫入資料如一般檔案。
      這些特殊裝置檔案 (Special device file) 都儲存於 <filename>/dev</filename>
      目錄中。</para>

    <para>
      目錄也同如檔案，擁有讀取、寫入及執行的權限，
      但在執行權限上與檔案有明顯的差異。 當目錄被標示為可執行時，代表可以使用
      <quote>cd</quote> (更改目錄) 進入該目錄。
      也代表能夠存取在此目錄之中的已知檔名的檔案
      (當然，檔案仍擁有自己的權限)</para>

    <para>尤其，要能夠列出目錄內容，必須擁有目錄的讀取權限。
      而當要刪除已知檔名的檔案時，也必須擁有檔案所在目錄的寫入
      <emphasis>以及</emphasis> 執行的權限。</para>

    <para>還有一些權限，但這些權限主要在特殊情況使用，如
      setuid binaries 及 sticky directories。
      如果您還想知道更多檔案權限的資訊及使用方法，請務必參閱
      &man.chmod.1; 說明文件。</para>

    <sect2>
      <info><title>權限符號</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contributed by </contrib></author>
	</authorgroup>
      </info>

      
      <indexterm><primary>permissions</primary><secondary>symbolic</secondary></indexterm>

      <para>權限符號可稱做符號表示，
	使用字元的方式來取代使用數值來設定檔案或目錄的權限。
	符號表示的格式依序為 (某人)(動作)(權限)，可使用的符號如下:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>項目</entry>
	      <entry>字母</entry>
	      <entry>意義</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry>(某人)</entry>
	    <entry>u</entry>
	    <entry>使用者</entry>
	  </row>

	  <row>
	    <entry>(某人)</entry>
	    <entry>g</entry>
	    <entry>群組所有者</entry>
	  </row>

	  <row>
	    <entry>(某人)</entry>
	    <entry>o</entry>
	    <entry>其他</entry>
	  </row>

	  <row>
	    <entry>(某人)</entry>
	    <entry>a</entry>
	    <entry>全部(<quote>world</quote>)</entry>
	  </row>

	  <row>
	    <entry>(動作)</entry>
	    <entry>+</entry>
	    <entry>增加權限</entry>
	  </row>

	  <row>
	    <entry>(動作)</entry>
	    <entry>-</entry>
	    <entry>移除權限</entry>
	  </row>

	  <row>
	    <entry>(動作)</entry>
	    <entry>=</entry>
	    <entry>指定權限</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>r</entry>
	    <entry>讀取</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>w</entry>
	    <entry>寫入</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>x</entry>
	    <entry>執行</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>t</entry>
	    <entry>Sticky bit</entry>
	  </row>

	  <row>
	    <entry>(權限)</entry>
	    <entry>s</entry>
	    <entry>Set UID 或 GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>如先前同樣使用 &man.chmod.1; 指令來設定，但使用的參數為這些字元。
      例如，您可以使用下列指令禁止其他使用者存取檔案
      <replaceable>FILE</replaceable>:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>若有兩個以上的符號表示可以使用逗號 (,) 區隔。
      例如，下列指令將會移除群組及其他人對檔案
      <replaceable>FILE</replaceable> 的寫入權限，
      並使全部人(<quote>world</quote>)對該檔有執行權限。</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x FILE</userinput></screen>

<!--
    <para>Most users will not notice this, but it should be pointed out
      that using the octal method will only set or assign permissions to
      a file; it does not add or delete them.</para>
-->
    </sect2>

    <sect2>
      <info><title>&os; 檔案旗標(Flag)</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Contributed by </contrib></author>
	</authorgroup>
      </info>

      

      <para>除了前面提到的檔案權限外，&os; 支援使用 <quote>檔案旗標</quote>。
	這些旗標增加了檔案的安全性及管理性，但不包含目錄。</para>

      <para>檔案旗標增加了管理性，確保在某些時候 <systemitem class="username">root</systemitem>
	不會意外將檔案修改或移除。</para>

      <para>修改的檔案 flag 僅需要使用擁有簡易的介面的 &man.chflags.1; 工具。
	例如，標示系統禁止刪除的旗標於檔案
	<filename>file1</filename>，使用下列指令：</para>

      <screen>&prompt.root; <userinput>chflags sunlink file1</userinput></screen>

      <para>若要移除系統禁止刪除的旗標，只需要簡單在 <option>sunlink</option>
	前加上 <quote>no</quote>，例如：</para>

      <screen>&prompt.root; <userinput>chflags nosunlink file1</userinput></screen>

      <para>使用 &man.ls.1; 及參數 <option>-lo</option>
	可檢視檔案目前的旗標：</para>

      <screen>&prompt.root; <userinput>ls -lo file1
	</userinput></screen>

      <para>輸出的結果如下:</para>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>多數的旗標僅能由 <systemitem class="username">root</systemitem>
	使用者來標示或移除，而部份旗標可由檔案所有者設定。
	我們建議系統管理者可閱讀 &man.chflags.1; 及 &man.chflags.2;
	說明以瞭解相關細節。</para>
    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>目錄結構</title>
    <indexterm><primary>directory hierarchy</primary></indexterm>

    <para>認識 FreeBSD 的目錄架構，就可對系統有概略的基礎理解。
      最重要的莫過於整個目錄的根目錄，就是 <quote>/</quote> 目錄，
      該目錄會在開機時最先掛載 (mount)，裡面會有開機所會用到必備檔案。
      此外，根目錄還有紀錄其他檔案系統的掛載點相關設定。</para>

    <para>「掛載點」就是讓新增的檔案系統，能接到上層的檔案系統
      (通常就是「根目錄」檔案系統) 的目錄。
      在 <xref linkend="disk-organization"/> 這邊對此有更詳細介紹。
      標準的掛載點包括了 <filename>/usr</filename>、<filename>/var</filename>、
      <filename>/tmp</filename>、<filename>/mnt</filename> 以及
      <filename>/cdrom</filename>。 這些目錄通常會記錄在
      <filename>/etc/fstab</filename> 設定檔內。
      <filename>/etc/fstab</filename> 是記錄各檔案系統及相關掛載點的表格。
      大部分在 <filename>/etc/fstab</filename> 有記錄的檔案系統，會在開機時由
      &man.rc.8; script 來自動掛載，除非它們有設定 <option>noauto</option>
      選項。 其中細節說明可參閱 <xref linkend="disks-fstab"/>。</para>

    <para>有關檔案系統架構的完整說明可參閱 &man.hier.7;。
      現在呢，讓我們大致先一窺常見的目錄有哪些吧。</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>目錄</entry>
	      <entry>說明</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename>/</filename></entry>
	      <entry>檔案系統的根目錄。</entry>
            </row>

	    <row>
	      <entry><filename>/bin/</filename></entry>
	      <entry>single-user、multi-user 兩種模式皆可使用的基本工具
		。</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/</filename></entry>
	      <entry>作業系統開機過程會用到的程式、設定檔。</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>
	      <entry>預設的開機啟動設定檔，詳情請參閱 &man.loader.conf.5;
		。</entry>
	    </row>

	    <row>
	      <entry><filename>/dev/</filename></entry>
	      <entry>Device nodes，詳情請參閱 &man.intro.4;。</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/</filename></entry>
	      <entry>系統設定檔及一些 script 檔。</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>
	      <entry>預設的系統設定檔，詳情請參閱 &man.rc.8;。</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail/</filename></entry>
	      <entry>MTA(Mail Transport Agent)的相關設定檔，像是
		&man.sendmail.8;。</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>
	      <entry><command>named</command> 設定檔，詳情請參閱
		&man.named.8;。</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>
	      <entry>每日、每週、每月透過 &man.cron.8;; 執行的定期排程 script，
		詳情請參閱 &man.periodic.8;。</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>
	      <entry><command>ppp</command> 設定檔，詳情請參閱
		&man.ppp.8;。</entry>
	    </row>

	    <row>
	      <entry><filename>/mnt/</filename></entry>
	      <entry>系統管理者慣用充當臨時掛載點的空目錄。</entry>
	    </row>

	    <row>
	      <entry><filename>/proc/</filename></entry>
	      <entry>Process 檔案系統，詳情請參閱 &man.procfs.5; 及
		&man.mount.procfs.8;。</entry>
	    </row>

	    <row>
	      <entry><filename>/rescue/</filename></entry>
	      <entry>緊急救援用途的一些 statically linked 程式，詳情請參閱
		&man.rescue.8;。</entry>
	    </row>

	    <row>
	      <entry><filename>/root/</filename></entry>
	      <entry><systemitem class="username">root</systemitem> 帳號的家目錄。</entry>
	    </row>

	    <row>
	      <entry><filename>/sbin/</filename></entry>
	      <entry>供 single-user 及 multi-user 環境使用的系統程式及管理工具
		。</entry>
	    </row>

	    <row>
	      <entry><filename>/tmp/</filename></entry>
	      <entry>臨時檔案。  一般而言，重開機之後
		<filename>/tmp</filename> 內的東西會被清除掉。
		而通常會將 memory-based 檔案系統掛載在
		<filename>/tmp</filename> 上。
		這些瑣事可透過 tmpmfs 相關的 &man.rc.conf.5; 環境變數來自動完成
		。(或是在 <filename>/etc/fstab</filename> 內做設定，
		詳情請參閱 &man.mdmfs.8;。)</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/</filename></entry>
	      <entry>主要是使用者所安裝的工具程式、應用程式存放處。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/bin/</filename></entry>
	      <entry>常用工具、開發工具、應用軟體。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/include/</filename></entry>
	      <entry>標準 C include 的相關 header 檔案庫。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/lib/</filename></entry>
	      <entry>函式庫存放處。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>
	      <entry>其他各式工具的資料檔。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>
	      <entry>系統 daemons 及系統工具程式(透過其他程式來執行)。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/</filename></entry>

	      <entry>存放一些自行安裝的執行檔、函式庫等等。 同時，也是 FreeBSD
		ports 架構的預設安裝目錄。 <filename>/usr/local</filename>
		內的目錄架構大致與 <filename>/usr</filename> 相同，詳情請參閱
		&man.hier.7; 說明。 但 man 目錄例外，它們是直接放在
		<filename>/usr/local</filename> 底下，而非
		<filename>/usr/local/share</filename>，而 ports
		所安裝的說明文件則在
		<filename>share/doc/port</filename>。
	      </entry>
	    </row>

	    <row>
	      <entry><filename>/usr/obj/</filename></entry>
	      <entry>在編譯 <filename>/usr/src</filename>
		目錄時所產生的相關架構 object 檔案。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/ports</filename></entry>
	      <entry>FreeBSD Ports Collection (optional)。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>
	      <entry>系統 daemon 及系統工具(直接由使用者執行)。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/share/</filename></entry>
	      <entry>各架構皆共通的檔案。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/src/</filename></entry>
	      <entry>BSD 本身的原始碼(或自行新增的)。</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/X11R6/</filename></entry>
	      <entry>X11R6 相關套件的執行檔、函式庫等(optional)。</entry>
	    </row>

	    <row>
	      <entry><filename>/var/</filename></entry>
	      <entry>存放各種用途的 log 檔、臨時或暫時存放、列印或郵件的
		spool 檔案。有時候，memory-based 檔案系統也會掛載在
		<filename>/var</filename>。
		這些瑣事可透過 varmfs 相關的 &man.rc.conf.5;
		環境變數來自動完成。(或是在
		<filename>/etc/fstab</filename> 內做設定，相關細節請參閱
		&man.mdmfs.8;。)</entry>
	    </row>


	    <row>
	      <entry><filename>/var/log/</filename></entry>
	      <entry>各項系統記錄的 log 檔案。</entry>
	    </row>

	    <row>
	      <entry><filename>/var/mail/</filename></entry>
	      <entry>各使用者的 mailbox 檔案。</entry>
	    </row>

	    <row>
	      <entry><filename>/var/spool/</filename></entry>
	      <entry>各種印表機、郵件系統的 spool 目錄。</entry>
	    </row>

	    <row>
	      <entry><filename>/var/tmp/</filename></entry>
	      <entry>臨時檔案。
		這些檔案在重開機後通常仍會保留，除非
		<filename>/var</filename>
		是屬於 memory-based 檔案系統。</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp</filename></entry>
	      <entry>記錄 NIS maps。</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>

  </sect1>

  <sect1 xml:id="disk-organization">
      <title>磁碟組織</title>

      <para>FreeBSD 用來尋找檔案的最小單位就是檔案的名稱了。
	檔案的名稱有大小寫之分，所以說 <filename>readme.txt</filename>
	和 <filename>README.TXT</filename> 是兩個不同的檔案。
	FreeBSD 並不使用副檔名 (<filename>.txt</filename>)
        來判別這是一個程式檔、文件檔或是其他類型的檔案。</para>

      <para>檔案存在目錄裡面。
	一個目錄中可能沒有任何檔案，也可能有好幾百個檔案。
	目錄之中也可以包含其他的目錄；
	您可以建立階層式的目錄以便資料的管理。</para>

      <para>檔案或目錄的對應是藉由給定的檔案或目錄名稱，然後加上正斜線符號
	(<literal>/</literal>)；之後再視需要加上其他的目錄名稱。
	如果您有一個目錄 <filename>foo</filename> ，裡面有一個目錄叫作
	<filename>bar</filename>，這個目錄中又包含了一個叫
	<filename>readme.txt</filename>
	的檔案，那麼這個檔案的全名，或者說檔案的<firstterm>路徑</firstterm>就是
	<filename>foo/bar/readme.txt</filename>。</para>

      <para>目錄及檔案儲存在檔案系統之中。
	每個檔案系統都有唯一一個最上層的目錄，叫做<firstterm>根目錄
	(root directory)</firstterm>。
	然後在這個根目錄下面才能有其他的目錄。</para>

      <para>到目前為止大概和其他您用過的的作業系統都差不多。
	還是有些不一樣的地方就是了，例如 &ms-dos; 用 <literal>\</literal>
	當檔案和目錄名稱的分隔符號，而 &macos; 則是用 <literal>:</literal>
        符號。</para>

      <para>FreeBSD 的路徑中並沒有使用磁碟機代號或其他的磁碟名稱。
	因此，您不可以使用像 <filename>c:/foo/bar/readme.txt</filename>
	這樣子的檔案名稱。</para>

      <para>相對的，在 FreeBSD
	系統中有一個檔案系統被指定為<firstterm>根檔案系統</firstterm>。
	根檔案系統的根目錄由 <literal>/</literal> 表示。
	然後其他的檔案系統再<firstterm>掛載 (mount)</firstterm>
	在根檔案系統之下。因此無論您的 FreeBSD
	系統上有多少顆硬碟，每一個目錄看起來就像在同一個磁碟上。</para>

      <para>假設您有三個檔案系統，分別叫作 <literal>A</literal>、
	<literal>B</literal> 及 <literal>C</literal>。
	每個檔案系統都包含兩個目錄，叫做
	<literal>A1</literal>、<literal>A2</literal> (依此類推得
	<literal>B1</literal>、<literal>B2</literal> 及
	<literal>C1</literal>、<literal>C2</literal>)。</para>

      <para>稱 <literal>A</literal> 為主要的檔案系統；如果您用
	<command>ls</command> 指令查看此目錄的內容，您會看到兩個子目錄：
	<literal>A1</literal> 及 <literal>A2</literal>，如下所示：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>一個檔案系統必須以目錄形式掛載於另一個檔案系統上。
	因此，假設您將 <literal>B</literal> 掛載於 <literal>A1</literal>
	之上，則 <literal>B</literal> 的根目錄就變成了
	<literal>A1</literal>，而在 <literal>B</literal>
	之下的任何目錄的路徑也隨之改變:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>在 <literal>B1</literal> 或	<literal>B2</literal>
	目錄中的任何檔案必須經由路徑 <filename>/A1/B1</filename>
	或 <filename>/A1/B2</filename> 才能達到。
	所有原來在 <filename>/A1</filename> 中的檔案會暫時被隱藏起來，直到
	<literal>B</literal> 被「<firstterm>移除
	(unmounted)</firstterm>」後才會再顯現出來。</para>

      <para>如果 <literal>B</literal> 掛載在 <literal>A2</literal>
	之上，則會變成：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>上面的路徑分別為 <filename>/A2/B1</filename> 及
	<filename>/A2/B2</filename>。</para>

      <para>檔案系統可以掛在其他檔案系統的目錄之上。
	延續之前的例子，<literal>C</literal> 檔案系統可以掛在檔案系統
	<literal>B</literal> 的 <literal>B1</literal>
	目錄之上，如圖所示：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>或者 <literal>C</literal> 直接掛載於 <literal>A</literal> 的
	<literal>A1</literal> 目錄之上：</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>如果您熟悉 &ms-dos; 的話，這和 <command>join</command>
	指令很類似 (雖然不儘相同)。</para>

      <para>一般情況下您不需要擔心這些東西。
	除非您要安裝新的磁碟，不然通常在您安裝 FreeBSD
        時建立好檔案系統並決定好要掛載在何處之後就不會再做任何更動了。</para>

      <para>您完全可以使用單一的一個大的根檔案系統 (root file system)
	而不建立其他的檔案系統。 這樣有好處也有有壞處。</para>

      <itemizedlist>
	<title>使用多個檔案系統的好處</title>

	<listitem>
	  <para>不同的檔案系統在掛上的時候可以有不同的
	    <firstterm>掛載參數</firstterm>。
	    舉例來說，為求謹慎您可以將根檔案系統設成唯讀，
	    以避免不小心刪除或修改掉重要的檔案。
	    將使用者可寫入的檔案系統 (例如 <filename>/home</filename>)
	    獨立出來也可以讓他們用 <firstterm>nosuid</firstterm>
	    的參數掛載，此選項可以讓在這個檔案系統中執行檔的
	    <firstterm>suid</firstterm>/<firstterm>guid</firstterm>
	    bits 失效，也許可以讓系統更安全。</para>
	</listitem>

	<listitem>
	  <para>FreeBSD 會自動根據您檔案系統的使用方式來做最佳的檔案配置方式。
	    因此，一個有很多小檔案、
	    常常寫入的檔案系統跟只有幾個較大的檔案的檔案系統配置是不一樣的。
	    如果您只有單一一個大的檔案系統，這部分就沒用了。</para>
	</listitem>

	<listitem>
	  <para>FreeBSD 的檔案系統在停電的時候很穩固。
	    然而，在某些重要的時候停電仍然會對檔案系統結構造成損害。
	    分割成許多個檔案系統的話在系統在停電後比較能夠正常啟動，
	    以便您在需要的時候將備份資料回存回來。</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>使用單一檔案系統的好處</title>

	<listitem>
	  <para>檔案系統的大小是固定的。
	    您當初安裝 FreeBSD
	    的時候應該會給定一個大小，可是後來您可能會想把空間加大。
	    如果沒有備份的話是很難達成的；
	    您必須將檔案系統重新建立為您需要的大小，然後將備份回存回來。</para>

	  <important>
	    <para>FreeBSD 的 &man.growfs.8;
	      指令可以突破此限制直接變更檔案系統的大小。</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>檔案系統包含在分割區裡面。
	因為 &os; 承襲 &unix; 架構，這邊講的分割區和一般提到的分割區
	(例如 &ms-dos; 分割區) 不同。 每一個分割區由一個代號(字母)表示，從
	<literal>a</literal> 到 <literal>h</literal>。
	每個分割區只能包含一個檔案系統。
	因此除了說常見到用檔案系統同的掛載點來表示檔案系統外，
	也可以用包含他的分割區代號來表示。</para>

      <para>FreeBSD 也會拿磁碟空間來當 <firstterm>swap space</firstterm>。
        Swap space 給 FreeBSD 當作<firstterm>虛擬記憶體</firstterm>用。
	這讓您的電腦好像擁有比實際更多的記憶體。
	當 FreeBSD 的記憶體用完的時候，它會把一些目前沒用到的資料移到
	swap space，然後在用到的時候移回去 (同時移出部份沒用到的)。</para>

      <para>某些分割區有慣例的使用方式如下：</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>分割區</entry>

	      <entry>慣例</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>通常包含根檔案系統 (root file system)</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>通常是 swap space</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>通常和整個 slice 的大小一樣，給一些會用到整個 slice
		的工具程式 (例如硬碟壞軌檢查工具) 來使用。
		一般來說您應該不會把檔案系統建立在這個分割區。</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>分割區 <literal>d</literal>
		曾經有代表特殊意義，但是已經不再使用。
		所以現在 <literal>d</literal>
		就和其他一般的分割區相同了。</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>每個包含有檔案系統的分割區是存在所謂的
	<firstterm>slice</firstterm> 裡面。
	FreeBSD 的 slice 就是指平常我們稱為分割區 (partition) 的東西。
	同樣地，會這樣子稱呼也是因為 FreeBSD 的 &unix; 色彩。
	而 slice 是有編號的，從 1 號編到 4 號。</para>

	<indexterm><primary>slices</primary></indexterm>
	<indexterm><primary>partitions</primary></indexterm>
	<indexterm><primary>dangerously dedicated</primary></indexterm>

      <para>slice 號碼跟在裝置名稱後面，先接一個字母
	<literal>s</literal>，然後從 1 號開始編下去。
	因此 <quote>da0<emphasis>s1</emphasis></quote> 就是指第一個 SCSI
	硬碟的第一個 slice。 一個磁碟上只能有四個實體的 slice，但是在實體的
	slice 中您可以塞進適當類型的邏輯 slice。 這些延伸的 slice 編號從 5
	開始，所以 <quote>ad0<emphasis>s5</emphasis></quote> 是第一個 IDE
	硬碟上的第一個延伸 slice。 檔案系統在裝置 (device) 裡就是在一個 slice
	之中。</para>

      <para>Slices、<quote>dangerously dedicated</quote>
        模式的實體磁碟機，以及其他包含<firstterm>分割區(partition)</firstterm>
	的磁碟都是以字母 <literal>a</literal> 到 <literal>h</literal>
	的編號來表示。  編號是接在裝置名稱的後面的，因此
	<quote>da0<emphasis>a</emphasis></quote> 是磁碟機 da 上的第一個
	<quote>dangerously dedicated</quote>模式之分割區。
	而 <quote>ad1s3<emphasis>e</emphasis></quote>
	則是第二顆 IDE 硬碟上第三個 slice 的第五個分割區。</para>

      <para>最後，我們就可以把系統上的每個磁碟都區分出來了。
	一個磁碟的名稱會有一個代碼來表示這個磁碟的類型，接著是一個數字，
	表示這是哪一個磁碟。 這邊跟 slice 每個磁碟編號從 0 開始不一樣。
	常見的代碼可以參考 <xref linkend="basics-dev-codes"/>。</para>

      <para>當要參照一個分割區的時候，FreeBSD 會要您一併輸入包含這個分割區的
	slice 及磁碟機名稱；當要參照一個 slice 的時候，也必須輸入包含這個
	slice 的磁碟名稱。  怎麼做呢？首先先列出磁碟名稱，然後
	<literal>s</literal> 加上 slice 編號，最後再輸入分割區字母代號。
	範例可以參考 <xref linkend="basics-disk-slice-part"/>.</para>

      <para><xref linkend="basics-concept-disk-model"/>
	示範了一個基本的磁碟分布模式，相信對您有些幫助。</para>

      <para>要安裝 FreeBSD，您必須先建置磁碟的 slice，接著於 slice 中建立要給
	FreeBSD 用的分割區。 最後在這些分割區中建立檔案系統 (或 swap space)
	並決定要將這些檔案系統掛載於哪裡。</para>

      <table frame="none" pgwide="1" xml:id="basics-dev-codes">
	<title>磁碟機代號</title>

	<tgroup cols="2">
          <colspec colwidth="1*"/>
          <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>代號</entry>

	      <entry>意義</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><filename>ad</filename></entry>

	      <entry>ATAPI(IDE) 磁碟機</entry>
	    </row>

	    <row>
	      <entry><filename>da</filename></entry>

	      <entry>SCSI 直接存取磁碟機</entry>
	    </row>

	    <row>
	      <entry><filename>acd</filename></entry>

	      <entry>ATAPI(IDE) 光碟機</entry>
	    </row>

	    <row>
	      <entry><filename>cd</filename></entry>

	      <entry>SCSI 光碟機</entry>
	    </row>

	    <row>
	      <entry><filename>fd</filename></entry>

	      <entry>軟碟機</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example xml:id="basics-disk-slice-part">
	<title>磁碟、slice 及分割區命名範例</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*"/>
            <colspec colwidth="5*"/>

	    <thead>
	      <row>
		<entry>名稱</entry>

		<entry>意義</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><literal>ad0s1a</literal></entry>

		<entry>第一個 IDE 硬碟 (<literal>ad0</literal>) 上第一個 slice
		  (<literal>s1</literal>)的第一個分割區(<literal>a</literal>)
		  。</entry>
	      </row>

	      <row>
		<entry><literal>da1s2e</literal></entry>
		<entry>第二個 SCSI 硬碟 (<literal>da1</literal>) 上第二個 slice
		  (<literal>s2</literal>) 的第五個分割區 (<literal>e</literal>)
		  。</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example xml:id="basics-concept-disk-model">
	<title>磁碟的概念模型</title>

	<para>此圖顯示 FreeBSD 中接到系統的第一個 IDE 磁碟機內部配置圖。
	  假設這個磁碟的容量是 4&nbsp;GB，並且包含了兩個 2&nbsp;GB 的
	  slice (&ms-dos; 的分割區)。 第一個 slice 是 DOS 的
	  <filename>C:</filename> 磁碟機，第二個則安裝了 FreeBSD。
	  本範例的 FreeBSD 有三個分割區以及一個 swap 分割區。</para>

	<para>這三個分割區每個都是一個檔案系統。
	  <literal>a</literal> 分割是根 (root) 檔案系統；分割
	  <literal>e</literal> 是 <filename>/var</filename>；而
	  <literal>f</literal> 分割是 <filename>/usr</filename>
	  目錄結構。</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout"/>
          </imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; file system, all
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     &gt; referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>



  <sect1 xml:id="mount-unmount">
    <title>掛載與卸載檔案系統</title>

    <para>檔案系統就像一顆樹。<filename>/</filename>
      就像是樹根，而 <filename>/dev</filename>，<filename>/usr</filename>
      以及其他在根目錄下的目錄就像是樹枝，而這些樹枝上面又還有分支，像是
      <filename>/usr/local</filename> 等。</para>

    <indexterm><primary>根檔案系統</primary></indexterm>
    <para>因為某些原因，我們會將一些目錄分別放在不同的檔案系統上。
      如 <filename>/var</filename> 包含了可能會滿出來的
      <filename>log/</filename>，<filename>spool/</filename>
      等目錄以及各式各樣的暫存檔。
      把根檔案系統塞到滿出來顯然不是個好主意，所以我們往往會比較傾向把
      <filename>/var</filename> 從 <filename>/</filename> 中拉出來。</para>

    <para>另一個常見到把某些目錄放在不同檔案系統上的理由是：
      這些檔案在不同的實體或虛擬磁碟機上。
      像是<link linkend="network-nfs">網路檔案系統</link>
      (Network File System) 或是光碟機。</para>

    <sect2 xml:id="disks-fstab">
      <title> <filename>fstab</filename> 檔</title>
      <indexterm>
	<primary>檔案系統 file systems</primary>
	<secondary>由fstab掛載 mounted with fstab</secondary>
      </indexterm>

      <para>在 <filename>/etc/fstab</filename>
	裡面有設定的檔案系統會在<link linkend="boot">開機</link>
	的過程中自動地被掛載
	(除非該檔案系統有被加上 <option>noauto</option> 參數)。</para>

      <para><filename>/etc/fstab</filename> 檔案內容的格式如下：</para>

      <programlisting><replaceable>device</replaceable>       <replaceable>/mount-point</replaceable> <replaceable>fstype</replaceable>     <replaceable>options</replaceable>      <replaceable>dumpfreq</replaceable>     <replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>
	  <listitem>
	    <para>裝置名稱 (該裝置必須真的存在)。 詳情請參閱
	      <xref linkend="disks-naming"/>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem><para>檔案系統要掛載到的目錄 (該目錄必須真的存在)。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
	    <para>檔案系統類型，這是要傳給 &man.mount.8; 的參數。
	      FreeBSD 預設的檔案系統是 <literal>ufs</literal>。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>可讀可寫的檔案系統用
	      <option>rw</option>，而唯讀的檔案系統則是用
	      <option>ro</option>，後面視需要還可以加其他選項。
	      常見的選項如 <option>noauto</option>
	      是用在不要於開機過程中自動的掛載的檔案系統。
	      其他選項可參閱 &man.mount.8; 說明。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem>
	    <para>&man.dump.8; 由此項目決定那些檔案系統需要傾印。
	      如果這格空白則以零為預設值。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem>
            <para>這個項目決定檔案系統檢查的順序。
	      對於要跳過檢查的檔案系統，它們的 <literal>passno</literal>
	      值要設為零。 根檔案系統的 <literal>passno</literal> 值應設為一
	      (因為需要比所有其他的還要先檢查)，而其他的檔案系統的
	      <literal>passno</literal> 值應該要設得比一大。
	      若有多個檔案系統具有相同的 <literal>passno</literal> 值，則
	      &man.fsck.8; 會試著平行地(如果可能的話)檢查這些檔案系統。</para>
         </listitem>
	</varlistentry>
      </variablelist>

      <para>更多關於 <filename>/etc/fstab</filename>
	檔案格式及選項的資訊請參閱 &man.fstab.5; 說明文件。</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title><command>mount</command> 指令</title>
      <indexterm>
	<primary>檔案系統 file systems</primary>
	<secondary>掛載 mounting</secondary>
      </indexterm>

      <para>&man.mount.8; 指令是拿來掛載檔案系統用的。</para>

      <para>基本的操作指令格式如下:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount device mountpoint</userinput></screen>
      </informalexample>

      <para>在 &man.mount.8;
	裡面有提到一大堆的選項，不過最常用的就是這些：</para>

      <variablelist>
	<title>掛載選項</title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>把 <filename>/etc/fstab</filename>
	      裡面所有還沒有被掛載、沒有被標記成 <quote>noauto</quote>
	      而且沒有用 <option>-t</option> 排除的檔案系統掛載起來。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
	    <para>執行所有的動作，但是不真的去呼叫掛載的 system call。
	      這個選項和 <option>-v</option> 搭配拿來推測 &man.mount.8;
	      將要做什麼動作時很好用。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>強迫掛載不乾淨的檔案系統 (危險)，或是用來強制取消寫入權限
	      (把檔案系統的掛載狀態從可存取變成唯讀)。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
          <term><option>-r</option></term>

	  <listitem>
	    <para>用唯讀的方式掛載檔案系統。 這個選項和在 <option>-o</option>
	      選項中指定 <option>ro</option> (在 &os; 5.2之前的版本是用
	      <option>rdonly</option>) 參數是一樣的。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
	    <para>用指定的檔案系統型態 (fstype)
	      來掛載指定的檔案系統，或是在有 <option>-a</option>
	      選項時只掛載指定型態的檔案系統。</para>

	    <para>預設的檔案系統是 <quote>ufs</quote>。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>更新檔案系統的掛載選項。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>顯示較詳細資訊。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>以可存取的模式掛載檔案系統。</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para><option>-o</option> 選項後面會接著以逗號分隔的參數，例如：</para>
      <variablelist>
	<varlistentry>
	  <term>noexec</term>

	  <listitem>
	    <para>不允許在這個檔案系統上執行二進位程式碼，
	      這也是一個蠻有用的安全選項。</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>不解析檔案系統上的 setuid 或 setgid 旗標，
	      這也是一個蠻有用的安全選項。</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title><command>umount</command> 指令</title>
      <indexterm>
	<primary>檔案系統 file systems</primary>
	<secondary>卸載 unmounting</secondary>
      </indexterm>

	<para>&man.umount.8; 指令的參數可以是掛載點
	  (mountpoint)，裝置名稱，以及 <option>-a</option> 或是
	  <option>-A</option> 等選項。</para>

	<para>加上 <option>-f</option> 可以強制卸載，加上 <option>-v</option>
	  則是會顯示詳細資訊。  要注意的是一般來說用 <option>-f</option>
	  並不是個好主意，強制卸載檔案系統有可能會造成電腦當機，
	  或者損壞檔案系統內的資料。</para>

	<para><option>-a</option> 和 <option>-A</option>
	  是用來卸載所有已掛載的檔案系統，另外還可以用 <option>-t</option>
	  來指定要卸載的是哪些種類的檔案系統。  要注意的是 <option>-A</option>
	  並不會試圖卸載根檔案系統。</para>

    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>程序</title>

    <para>FreeBSD 是一個多工的作業系統，也就是說在同一時間內可以跑超過一個程式。
      每一個正在花時間跑的程式就叫做 <firstterm>程序 (process)</firstterm>。
      您下的每個指令都至少會開啟一個新的程序，
      而有些系統程序是一直在跑以維持系統正常運作的。</para>

    <para>每一個程序都有一個不重覆的數字叫做 <firstterm>process ID
      </firstterm>，或稱為 <firstterm>PID
      </firstterm>，而且就像檔案一樣，每一個程序也有擁有者及群組。
      擁有者及群組的資訊是用來決定什麼檔案或裝置是這個程序可以開啟的
      (前面有提到過檔案權限)。 大部份的程序都有父程序。
      父程序是開啟這個程序的程序，例如：您對 shell 輸入指令，shell
      本身就是一個程序，而您執行的指令也是程序。
      每一個您用這種方式跑的程序的父程序都是 shell。
      有一個特別的程序叫做 &man.init.8; 是個例外。<command>init</command>
      永遠是第一個程序，所以他的 PID 一直都會是 1。 在 FreeBSD 開機的時候
      <command>init</command> 會自動地被 kernel 開啟。</para>

    <para>要看系統執行中的程序，有兩個相當有用的指令可用：
      &man.ps.1; 以及 &man.top.1;。<command>ps</command>
      指令是用來列出正在執行之程序，而且可以秀它們的
      PID、用了多少記憶體、執行的指令名稱及其後之參數是什麼等等。
      <command>top</command> 指令則是顯示所有正在執行的程序，
      並且數秒鐘更新一次。因此您可以互動式的觀看您的電腦正在做什麼。</para>

    <para>在預設的情況下，<command>ps</command>
      指令只會顯示您所擁有的的程序。 例如：</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
48630  p0  S      2:50.89 /usr/local/lib/netscape-linux/navigator-linux-4.77.bi
48730  p0  IW     0:00.00 (dns helper) (navigator-linux-)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>在這個範例裡可以看到 &man.ps.1; 的輸出分成好幾個欄位。
      <literal>PID</literal> 就是前面有提到的 process ID。 PID 的分配是從
      1 開始一直到 99999，如果用完的話又會繞回來重頭開始分配
      (若該 PID 已經在用了，則 PID 不會重新分配)。
      <literal>TT</literal> 欄位是指這個程式在哪個 tty
      上執行，在這裡可以先忽略不管。<literal>STAT</literal>
      是程式的狀態，也可以先不要管。<literal>TIME</literal> 是這個程式在
      CPU 上執行的時間&mdash;這通常不是程式總共花的時間，
      因為當您開始執行程式後，大部份的程式在 CPU 上執行前會先花上不少時間等待
      。  最後，<literal>COMMAND</literal> 是執行這個程式的命令列。</para>

    <para>&man.ps.1;
      有幾個不同的選項組合可以用來變更顯示出來的資訊，其中一個最有用的組合是
      <literal>auxww</literal>。
      <option>a</option> 可以顯示所有正在跑的程序的指令，不只是您自已的。
      <option>u</option> 則是顯示程序的擁有者名稱以及記憶體使用情況。
      <option>x</option> 可以把 daemon 程序顯示出來，
      而 <option>ww</option> 可讓 &man.ps.1; 顯示出每個程序完整的內容，
      而不致因過長而被螢幕截掉了。</para>

    <para>&man.top.1; 也有類似的輸出。  一般的情況看像是這樣：</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
48630 nik        2   0 29816K  9148K select   3:18  0.00%  0.00% navigator-linu
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>輸出的資訊分成兩個部份。開頭 (前五行) 秀出最近一個程序的
      PID、系統平均負載 (系統有多忙錄的測試)、系統的開機時間
      (從上次重開算起) 以及現在的時間等。
      在開頭裡面的其他數字分別是在講有多少程序正在執行
      (在本例中為47)、有多少記憶體及 swap space
      被占用了，還有就是系統分別花了多少時間在不同的 CPU 狀態上。</para>

    <para>接下來的部份是由好幾個欄位所構成，和 &man.ps.1; 輸出的資訊類似。
      就如同前例，您可以看到 PID、使用者名稱、CPU
      花費的時間以及正在執行的指令。 &man.top.1;
      在預設的情況下還會告訴您程序用掉了多少的記憶體空間。
      在這邊會分成兩欄，一個是總用量 (total size)，另一個是實際用量
      (resident size)&mdash;總用量是指這個應用程式需要的記憶體空間，
      而實際用量則是指實際上該程式的記憶體使用量。
      在這個例子裡面您可以看到 <application>&netscape;</application>
      要了幾乎到 30 MB 的 RAM，但是只有用到 9 MB。</para>

    <para>&man.top.1; 每隔 2 秒鐘會自動更新顯示內容，可用 <option>s</option>
      選項來改變間隔的時間。</para>

  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>Daemon、信號及終止程序</title>

    <para>當在執行文書編輯器時，您可以很容易地使用它，叫它讀取檔案或是什麼的。
      可以這樣做是因為編輯器有提供這些功能，
      還有就是編輯器依附在一個<firstterm>終端機 (Terminal) </firstterm>之上。
      有些程式並不是設計成一直在接收使用者的輸入的，
      所以它們在一開始執行的時候就從終端機斷開了。 例如說，
      網頁伺服器整天都在回應網頁方面的要求，它通常不需要您輸入任何東西。
      另外，像是把信從一個站傳送到另一個站的程式，也是這種類型的應用程式。
      </para>

    <para>我們把這種程式稱作 <firstterm>daemon</firstterm>。
      Daemon (惡魔、守護神)
      是希臘神話中的角色：祂們不屬於善良陣營或邪惡陣營，是守護的小精靈。
      大致上來說祂們就是在替人類做一些有用的事情，
      跟今天的網頁伺服器或是郵件伺服器很像。  這也就是為何 BSD
      的吉祥物，長期以來都是一隻穿著帆布鞋拿著三叉耙的快樂小惡魔的原因。</para>

    <para>通常來說 deamon 程式的名字後面都會加一個字母 <quote>d</quote>。
      <application>BIND</application> 是 Berkeley Internet Name Domain
      的縮寫 (但實際上執行的程式名稱是 <command>named</command>)、Apache
      網頁伺服器的程式名稱是 <command>httpd</command>、印表機服務程式是
      <command>lpd</command>，依此類推。
      這是習慣用法，並沒有硬性規定，例如 <application>Sendmail</application>
      主要的寄信 daemon 是叫做 <command>sendmail</command> 而不是
      <command>maild</command>，跟您想像的不一樣。</para>

    <para>有些時候會需要跟某個 daemon 程序溝通，
      這些溝通是透過所謂的<firstterm>信號(signal)</firstterm>來傳遞給該 daemon
      程序(或是其他執行中的程序)。
      藉由送出信號，您可以和一個 daemon (或是任何一個正在跑的程序) 溝通。
      信號有很多種&mdash;有些有特定的意義，有些則是會由應用程式來解讀。
      應用程式的說明文件會告訴您該程式是如何解讀信號的。
      您只能送信號給您擁有的程序，送 &man.kill.1; 或 &man.kill.2;
      的信號給別人的程序是不被允許的。 不過 <systemitem class="username"> root </systemitem>
      不受此限制，他可以送信號給任何人的程序。</para>

    <para>FreeBSD 本身在某些情況也會送信號給應用程式。
      假設有個應用程式寫得很爛，然後企圖要存取它不該碰的記憶體的時候，FreeBSD
      會送一個 <firstterm>Segmentation Violation</firstterm> 信號
      (<literal>SIGSEGV</literal>) 給這個程序。
      又如果有一個應用程式用了 &man.alarm.3; 的 system call
      要求系統在過一段時間之後叫他一下，時間到了的時候鬧鐘的信號
      (<literal>SIGALRM</literal>) 就會被送出了，其他的依此類推。</para>

    <para><literal>SIGTERM</literal> and <literal>SIGKILL</literal>
      這兩個信號可以拿來終止程序。 用 <literal>SIGTERM</literal>
      結束程序是比較有禮貌的方式，該程序會<emphasis>捕捉 (catch) </emphasis>
      這個信號而了解到您想要把他關掉。 接著下來它會把它自已開的記錄檔通通關掉，
      然後在關掉程序之前結束掉手邊的工作。 在某些情況下程序有可能會裝作沒看見
      <literal>SIGTERM</literal>，假如它正在做一些不能中斷的工作的話。</para>

    <para><literal>SIGKILL</literal> 就沒有辦法被程序忽略了。
      這是一個<quote>我管你正在幹嘛，現在就給我停下來</quote>的信號。
      如果您送了 <literal>SIGKILL</literal> 信號給某個程序，FreeBSD
      將會把它停掉<footnote>
	<para>不完全正確&mdash;還是有少數東西不能被中斷。
	  例如有個程序正在從網路上的別的電腦讀一個檔案，
	  而那部電腦因為某些理由連不到 (機器被關掉，或是網路爛掉了)，
	  那這個程序我們就說他是一個<quote>不能中斷的</quote>程序。
	  通常在經過兩分鐘左右之後這個程序會逾時。
	  當發生逾時的時候這個程序就會被結束掉了。</para>
      </footnote>。</para>

    <para>這些是其他您有可能會要用到的信號：
      <literal>SIGHUP</literal>，<literal>SIGUSR1</literal>，以及
      <literal>SIGUSR2</literal>。
      這些是通用的信號，當送出時不同的應用程式會有不同的反應。</para>

    <para>假設您更動了您的網頁伺服器的設定檔&mdash;
      您想要叫網頁伺服器去重新讀取設定值。 您可以關閉後再重新啟動
      <command>httpd</command>，但是這麼做會造成網頁伺服器暫停服務一段時間，
      這樣子可能不太好。
      大部份的 daemon 都寫成會去回應 <literal>SIGHUP</literal>。
      當收到這個信號之後，它們會去重新讀取自已的設定檔。
      因此您可以用送 <literal>SIGHUP</literal> 信號來取代關掉重開。
      又因為沒有標準在規範如何回應這些信號，不同的 daemon
      可能會有不同的行為，所以有疑問的話請先確認並翻閱 deamon
      的說明文件。</para>

    <para>信號是由 &man.kill.1; 指令送出的，如範例所示：</para>

    <procedure>
      <title>送信號給程序</title>

      <para>這個範例將會示範如何送一個信號給 &man.inetd.8;。
        <command>inetd</command> 的設定檔是
        <filename>/etc/inetd.conf</filename>，而 <command>inetd</command>
        會在收到 <literal>SIGHUP</literal> 的時候重新讀取這個設定檔。</para>

      <step>
        <para>找出您想要送信號的那個程序的 ID。 您會用到 &man.ps.1; 以及
          &man.grep.1; 這兩個指令。  &man.grep.1; 是用來在輸出中搜尋，
	  找出您指定的字串。  這個指令是由一般使用者執行，而 &man.inetd.8;
          是由 <systemitem class="username">root</systemitem> 執行，所以在使用 &man.ps.1; 時需要加上
	  <option>ax</option> 選項。</para>

        <screen>&prompt.user; <userinput>ps -ax | grep inetd</userinput>
  198  ??  IWs    0:00.00 inetd -wW</screen>

        <para>因此可知 &man.inetd.8; 的 PID 為 198。  在某些情況下
	  <literal>grep inetd</literal> 這個指令本身也會出現在輸出裡。
          這是因為 &man.ps.1; 乃是找所有執行中的程序的方式造成的。</para>
      </step>

      <step>
        <para>用 &man.kill.1; 來送信號。 又因為 &man.inetd.8; 是由
	  <systemitem class="username">root</systemitem> 執行的，您必須用 &man.su.1; 切換成
          <systemitem class="username">root</systemitem>先。</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

        <para>一般情況對大多數 &unix; 指令來講，當 &man.kill.1;
	  執行成功時並不會輸出任何訊息。
	  假設您送一個信號給某個不是您所擁有的程序，
	  那麼您就會吃到這個錯誤訊息： <errorname>kill:
	  <replaceable>PID</replaceable>: Operation not permitted</errorname>。
	  而如果您打錯 PID 的話，那就會把信號送給錯誤的程序。 這樣可能會很糟，
	  不過如果您夠幸運的話，可能剛好就只是把信號送給一個非使用中的
	  PID，那您就只會看到 <errorname>kill:
	  <replaceable>PID</replaceable>: No such process</errorname> 而已。
	  </para>

	<note>
	  <title>為什麼用 <command>/bin/kill</command>？</title>

          <para>很多 shell 有提供內建的 <command>kill</command> 指令。
	    也就是說這種 shell 會直接送信號，而不是執行
	    <filename>/bin/kill</filename>。
	    這樣是蠻方便的沒錯啦，但是不同的 shell
	    會有不同的語法來指定信號的名稱等。
	    與其嘗試去把它們通通學會，不如就單純的直接用 <command>/bin/kill
	    ...</command> 吧。</para>
	</note>
      </step>
    </procedure>

    <para>要送其他的信號的話也是非常類似，就視需要把指令中的
      <literal>TERM</literal> 或 <literal>KILL</literal>
      替換掉即可。</para>

    <important>
      <para>隨便抓一個系統中的程序然後把他砍掉並不是個好主意。
        特別是 &man.init.8;， process ID 1，一個非常特別的程序。
        執行 <command>/bin/kill -s KILL 1</command>
        的結果就是系統立刻關機。 因此在您按下 <keycap>Return</keycap>
        要執行 &man.kill.1;<emphasis>之前</emphasis>，
        請<emphasis>一定</emphasis>要記得再次確認您下的參數。</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>Shells</title>
    <indexterm><primary>shells</primary></indexterm>
    <indexterm><primary>命令列 command line</primary></indexterm>

    <para>在 FreeBSD 中，很多日常的工作是在一個叫做 shell
      的文字介面中完成的。
      Shell 的主要工作就是從輸入中收到命令並執行它們。
      許多 shell 也有內建一些有助於日常工作的指令，
      像是檔案管理、檔案比對、命令列編輯、指令巨集以及環境變數等。
      FreeBSD 有內附了幾個 shell，像是 <command>sh</command>，
      Bourne Shell，以及 <command>tcsh</command>，改良版的 C-shell。
      還有許多其他的 shell 可以從 FreeBSD Ports Collection
      中取得，像是 <command>zsh</command> 以及 <command>bash</command>
      等。</para>

    <para>您用哪個 shell 呢？ 其實每個人的喜好都不一樣。
      如果您是一個 C 程式設計師，那對於使用像是 <command>tcsh</command>
      這種 C-like 的 shell 可能會感到相當愉快。 如果你是從 Linux
      跳過來的，或者您是一個 &unix; 新手，那您也許會想要用
      <command>bash</command> 來當作文字介面。
      每一個 shell 都有自已獨特之處，至於這些特點能不能配合您的工作環境？
      那就是您選擇 shell 的重點了。</para>

    <para>檔名自動補齊就是常見的 shell 功能。
      首先輸入指令或檔案的前幾個字母，這時通常您只需要按下 <keycap>Tab</keycap>
      鍵，接下來 shell 就會自動把指令或是檔案名稱剩餘的部份補齊。
      假設您有兩個檔案分別叫作 <filename>foobar</filename> 及
      <filename>foo.bar</filename>。  現在要刪掉
      <filename>foo.bar</filename>，那麼可以輸入：
      <command>rm fo[Tab].[Tab]</command>
      </para>

    <para>Shell 會印出這個： <command>rm foo[嗶].bar</command>。</para>

    <para>[嗶] 是 console 的響鈴，這嗶的一聲是 shell
      在告訴我說它沒有辦法完全自動補齊檔名，因為有不只一個檔名符合條件。
      <filename>foobar</filename> 和 <filename>foo.bar</filename> 都是
      <literal>fo</literal> 開頭的檔名，不過它至少可以補齊到 <literal>foo</literal>。
      如果您接著輸入 <literal>.</literal> 然後再按 <keycap>Tab</keycap>
      一次，那 shell 就能夠替您把剩下的檔名填滿了。</para>

    <indexterm><primary>environment variables</primary></indexterm>

    <para>Shell 的另一項特點是使用了環境變數。
      環境變數是以變數與鍵值（variable/key）的對應關係儲存於 shell
      的環境空間中，任何由 shell 所產生的程序都可以讀取此空間，
      因此這個空間儲存了許多程序的設定組態。  在此附上
      一份常見環境變數與其涵義的列表：</para>
    <indexterm><primary>environment variables</primary></indexterm>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>變數</entry>
	    <entry>詳細說明</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>目前登入的使用者名稱。</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>以冒號（:）隔開的目錄列表，用以搜尋執行檔的路徑。</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>若存在這個環境變數，則代表 X11 連結顯示器的網路名稱。</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>目前使用的 shell。</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>使用者終端機的名稱，能藉由此變數判斷終端機的能力。</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Database entry of the terminal escape codes to perform
	      various terminal functions.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>作業系統的種類，如：FreeBSD。</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>目前系統所用的 CPU 架構。</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>使用者偏好的文字編輯器。</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>使用者偏好的文字分頁器（text pager）。</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>以冒號（:）隔開的目錄列表，用以搜尋 manual pages 的路徑。</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm><primary>Bourne shells</primary></indexterm>
    <para>在不同的 shell 底下設定環境變數的方式也有所不同。
      舉例來說，在 C-Style 的 shell 底下，像是
      <command>tcsh</command> 和 <command>csh</command>，你必須使用
      <command>setenv</command> 來設定環境變數。
      但在 Bourne shells 底下，像是 <command>sh</command> 和
      <command>bash</command>，你則必須使用
      <command>export</command> 來設定你所使用的環境變數。
      再舉個例子來說，若要設定或是修改
      <envar>EDITOR</envar> 這個環境變數，在 <command>csh</command> 或
      <command>tcsh</command> 下設定 <envar>EDITOR</envar> 這個環境變數為
      <filename>/usr/local/bin/emacs</filename> 的指令是：</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>在 Bourne shells 下則是：</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>大多數的 shell 都支援使用者在命令列中將
      <literal>$</literal> 字元放在變數之前，以取得環境變數的值。
      舉例來說，<command>echo $TERM</command> 會
      顯示出 <envar>$TERM</envar> 的設定值，這是因為 shell 取得了
      <envar>$TERM</envar> 的設定值，
      並將其傳給 <command>echo</command> 顯示出來。</para>

    <para>Shell 中有某些特別的字元是來表示特殊的資料，我們將其稱作
      meta-characters。  其中最常見的是
      <literal>*</literal> 字元，他代表了檔名中的任意字元。
      這些特殊字元可以用在檔名展開（filename globbing）上，舉例來說，輸入
      <command>echo *</command> 會和輸入
      <command>ls</command> 得到幾乎相同的結果，這是因為 shell 會將所有符合
      <literal>*</literal> 字元的檔案傳到命令列上，再由
      <command>echo</command> 顯示出來。</para>

    <para>為了避免 shell 轉譯這些特殊字元，我們可以在這些特殊字元前放一個反斜線
      (<literal>\</literal>) 字元使他們跳脫(escape) shell 的轉譯。舉例來說，
      <command>echo $TERM</command> 會印出你目前設定的終端機格式，
      <command>echo \$TERM</command> 則會直接印出 <envar>$TERM</envar>
      這幾個字。</para>

    <sect2 xml:id="changing-shells">
      <title>變更你的 Shell</title>

      <para>變更 shell 最簡單的方法就是透過 <command>chsh</command> 命令。
        執行 <command>chsh</command> 將會呼叫環境變數中 <envar>EDITOR</envar>
	指定的文字編輯器。  如果沒有設定，則預設是 <command>vi</command>。
	請依照需求去修改 <quote>Shell:</quote> 的值。</para>

      <para>你也可以透過 <command>chsh</command> 的參數 <option>-s</option>，
	這可以直接設定你的 shell 而不需要透過任何文字編輯器。  例如，
	假設想把所用的 shell 改為 <command>bash</command>，
	可以透過下列的方式：</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>你所使用的 shell <emphasis>必須</emphasis> 列於
	  <filename>/etc/shells</filename> 裡頭。  如果是由
	  <link linkend="ports">Ports Collection</link> 來裝 shell，
	  那這個步驟已經完成了。  但若是手動安裝了一個 shell，
	  那麼就必須為新安裝的 shell 進行設定。</para>

      <para>舉例來說，若手動安裝了 <command>bash</command> 並將它置於
	  <filename>/usr/local/bin</filename> 底下，你還得：</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>然後再重新執行 <command>chsh</command>。</para>
     </note>
   </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>文字編輯器</title>
    <indexterm><primary>text editors</primary></indexterm>
    <indexterm><primary>editors</primary></indexterm>

    <para>在 FreeBSD 中有許多設定必須透過編輯文字檔完成。
      因此，若能熟悉文字編輯器是再好不過的。
      FreeBSD 本身（指 base system）就附有幾種文字編輯器，
      此外，你也可以透過 Ports Collection 來安裝其他的文字編輯器。</para>

    <indexterm>
      <primary><command>ee</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>
    <para>最簡單易學的文字編輯器叫做 <application>ee</application>，
      代表了其全名 easy editor。  要開始使用 <application>ee</application>，
      必須在命令列上輸入
      <command>ee filename</command>，
      這邊的 <replaceable>filename</replaceable> 代表你想要編輯的檔案名稱。
      舉例來說，要編輯 <filename>/etc/rc.conf</filename>，就要輸入
      <command>ee /etc/rc.conf</command>。
      而在 <command>ee</command> 的操作介面下，
      所有編輯器的功能與操作都會顯示在螢幕的正上方。
      其中的插入符號(<literal>^</literal>)代表鍵盤上的 <keycap>Ctrl</keycap>
      鍵，所以 <literal>^e</literal> 就等同於
      <keycombo action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      。  若要結束 <application>ee</application>，請按下 <keycap>Esc</keycap>
      鍵，接著選擇 leave editor 即可。
      此時如果該檔案有修改過，編輯器會提醒你是否要存檔。</para>

    <indexterm>
      <primary><command>vi</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>vi</command></secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>editors</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>

    <para>此外，FreeBSD 也內附了幾個好用的文字編輯器，像是 base system 的
      <application>vi</application> 及 FreeBSD Ports Collection 內的其他編輯器，
      比如 <application>Emacs</application> 及 <application>vim</application>
      (<package>editors/emacs</package> 及
      <package>editors/vim</package>)。
      這些文字編輯器提供更強的功能，但是也比較難學習。
      然而若要從事大量文字編輯工作，
      那麼花點時間來學習這些好用的編輯器，
      會在日後為您省下更多的時間。</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>設備及設備節點</title>

    <para>設備(device)主要是指跟硬體比較有關的術語，
      包括磁碟、印表機、顯示卡和鍵盤。  FreeBSD 開機過程當中，
      大多數硬體通常都能偵測到並顯示出來，也可以查閱
      <filename>/var/run/dmesg.boot</filename> 內有開機的相關訊息。</para>

    <para>舉例來說，<filename>acd0</filename>即為第一台 IDE 光碟機的代號，
      而 <filename>kbd0</filename> 則代表鍵盤。</para>

    <para>在 &unix; 作業系統，
      大部分的設備都是透過叫做 device nodes(設備節點)的特殊檔案來作存取，
      而這些檔案都位於 <filename>/dev</filename> 目錄。</para>

    <sect2>
      <title>建立設備節點</title>
      <para>若要在系統上建立新節點，或者是要編譯某些新硬體的支援軟體，
	那麼就要先新增設備節點。</para>

      <sect3>
	<title><literal>DEVFS</literal> (DEVice File System)</title>

	<para>設備檔案系統(或稱為 <literal>DEVFS</literal>) 是指在整體檔案系統
	  namespace 提供 kernel 的設備 namespace。  <literal>DEVFS</literal>
	  乃是維護這些檔案系統，而不能新增或修改這些設備節點。</para>

	<para>細節請參閱 &man.devfs.5; 說明。</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="binary-formats">
    <title>Binary 的格式</title>

    <para>若要知道為何 &os; 是採用 &man.elf.5; 格式，必先瞭解當前 &unix;
      系統中三種<quote>影響最為重大</quote>的可執行檔相關背景：</para>

    <itemizedlist>
      <listitem>
        <para>&man.a.out.5;</para>

        <para>最古老、<quote>經典</quote> 的 &unix; object 檔格式。
          It uses a short and compact header with a magic
          number at the beginning that is often used to characterize
          the format (see &man.a.out.5; for more details).  It
          contains three loaded segments: .text, .data, and .bss plus
          a symbol table and a string table.</para>
      </listitem>

      <listitem>
        <para><acronym>COFF</acronym></para>

        <para>The SVR3 object format.  The header now comprises a
          section table, so you can have more than just .text, .data,
          and .bss sections.</para>
      </listitem>

      <listitem>
        <para>&man.elf.5;</para>

        <para>The successor to <acronym>COFF</acronym>, featuring
          multiple sections and 32-bit or 64-bit possible values.  One
          major drawback: <acronym>ELF</acronym> was also designed
          with the assumption that there would be only one ABI per
          system architecture.  That assumption is actually quite
          incorrect, and not even in the commercial SYSV world (which
          has at least three ABIs: SVR4, Solaris, SCO) does it hold
          true.</para>

        <para>FreeBSD tries to work around this problem somewhat by
          providing a utility for <emphasis>branding</emphasis> a
          known <acronym>ELF</acronym> executable with information
          about the ABI it is compliant with.  See the manual page for
          &man.brandelf.1; for more information.</para>
      </listitem>
    </itemizedlist>

    <para>FreeBSD comes from the <quote>classic</quote> camp and used
      the &man.a.out.5; format, a technology tried and proven through
      many generations of BSD releases, until the beginning of the 3.X
      branch. Though it was possible to build and run native
      <acronym>ELF</acronym> binaries (and kernels) on a FreeBSD
      system for some time before that, FreeBSD initially resisted the
      <quote>push</quote> to switch to <acronym>ELF</acronym> as the
      default format. Why?  Well, when the Linux camp made their
      painful transition to <acronym>ELF</acronym>, it was not so much
      to flee the <filename>a.out</filename> executable format as it
      was their inflexible jump-table based shared library mechanism,
      which made the construction of shared libraries very difficult
      for vendors and developers alike. Since the
      <acronym>ELF</acronym> tools available offered a solution to the
      shared library problem and were generally seen as <quote>the way
      forward</quote> anyway, the migration cost was accepted as
      necessary and the transition made.  FreeBSD's shared library
      mechanism is based more closely on Sun's
      &sunos; style shared library mechanism
      and, as such, is very easy to use.</para>

    <para>So, why are there so many different formats?</para>

    <para>Back in the dim, dark past, there was simple hardware.  This
      simple hardware supported a simple, small system. <filename>a.out</filename> was
      completely adequate for the job of representing binaries on this
      simple system (a PDP-11). As people ported &unix; from this simple
      system, they retained the <filename>a.out</filename> format because it was sufficient
      for the early ports of &unix; to architectures like the Motorola
      68k, VAXen, etc.</para>

    <para>Then some bright hardware engineer decided that if he could
      force software to do some sleazy tricks, then he would be able
      to shave a few gates off the design and allow his CPU core to
      run faster. While it was made to work with this new kind of
      hardware (known these days as <acronym>RISC</acronym>), <filename>a.out</filename>
      was ill-suited for this hardware, so many formats were developed
      to get to a better performance from this hardware than the
      limited, simple <filename>a.out</filename> format could
      offer. Things like <acronym>COFF</acronym>,
      <acronym>ECOFF</acronym>, and a few obscure others were invented
      and their limitations explored before things seemed to settle on
      <acronym>ELF</acronym>.</para>

    <para>In addition, program sizes were getting huge and disks (and
      physical memory) were still relatively small so the concept of a
      shared library was born. The VM system also became more
      sophisticated. While each one of these advancements was done
      using the <filename>a.out</filename> format, its usefulness was
      stretched more and more with each new feature.  In addition,
      people wanted to dynamically load things at run time, or to junk
      parts of their program after the init code had run to save in
      core memory and swap space. Languages became more sophisticated
      and people wanted code called before main automatically. Lots of
      hacks were done to the <filename>a.out</filename> format to
      allow all of these things to happen, and they basically worked
      for a time. In time, <filename>a.out</filename> was not up to
      handling all these problems without an ever increasing overhead
      in code and complexity. While <acronym>ELF</acronym> solved many
      of these problems, it would be painful to switch from the system
      that basically worked. So <acronym>ELF</acronym> had to wait
      until it was more painful to remain with
      <filename>a.out</filename> than it was to migrate to
      <acronym>ELF</acronym>.</para>

    <para>However, as time passed, the build tools that FreeBSD
      derived their build tools from (the assembler and loader
      especially) evolved in two parallel trees. The FreeBSD tree
      added shared libraries and fixed some bugs. The GNU folks that
      originally wrote these programs rewrote them and added simpler
      support for building cross compilers, plugging in different
      formats at will, and so on. Since many people wanted to build cross
      compilers targeting FreeBSD, they were out of luck since the
      older sources that FreeBSD had for <application>as</application> and <application>ld</application> were not up to the
      task. The new GNU tools chain (<application>binutils</application>) does support cross
      compiling, <acronym>ELF</acronym>, shared libraries, C++
      extensions, etc. In addition, many vendors are releasing
      <acronym>ELF</acronym> binaries, and it is a good thing for
      FreeBSD to run them.</para>

    <para><acronym>ELF</acronym> is more expressive than <filename>a.out</filename> and
      allows more extensibility in the base system. The
      <acronym>ELF</acronym> tools are better maintained, and offer
      cross compilation support, which is important to many people.
      <acronym>ELF</acronym> may be a little slower than <filename>a.out</filename>, but
      trying to measure it can be difficult. There are also numerous
      details that are different between the two in how they map
      pages, handle init code, etc. None of these are very important,
      but they are differences. In time support for
      <filename>a.out</filename> will be moved out of the <filename>GENERIC</filename>
      kernel, and eventually removed from the kernel once the need to
      run legacy <filename>a.out</filename> programs is past.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>更多資訊</title>

    <sect2 xml:id="basics-man">
      <title>Manual 線上說明</title>
      <indexterm><primary>manual pages</primary></indexterm>

      <para>在使用 FreeBSD 時，最詳細的使用說明莫過於 man 線上說明。
	幾乎各程式都會有附上簡短說明，以介紹該程式的基本功能跟相關參數用法。
	可以透過 <command>man</command> 指令來閱讀這些說明，而
	<command>man</command> 指令的使用相當簡單易懂：</para>

      <screen>&prompt.user; <userinput>man command</userinput></screen>

      <para><literal>command</literal> 處就是想要知道的指令。  舉個例子，
	若要知道 <command>ls</command> 的詳細用法，就可以打：</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>而各線上說明因為性質不同，而區分為下列的數字章節：</para>

      <orderedlist>
	<listitem>
	  <para>使用者指令。</para>
	</listitem>

	<listitem>
	  <para>系統呼叫(System call) 及錯誤代號。</para>
	</listitem>

	<listitem>
	  <para>C 語言函式庫。</para>
	</listitem>

	<listitem>
	  <para>各設備的驅動程式。</para>
	</listitem>

	<listitem>
	  <para>檔案格式。</para>
	</listitem>

	<listitem>
	  <para>小遊戲程式及其他娛樂程式。</para>
	</listitem>

	<listitem>
	  <para>雜項工具、其他資訊。</para>
	</listitem>

	<listitem>
	  <para>系統維護、操作的指令。</para>
	</listitem>

	<listitem>
	  <para>Kernel 開發用途。</para>
	</listitem>
      </orderedlist>

      <para>有些情況會有同樣主題但不同章節。  舉個例子，系統內會有
	<command>chmod</command> 指令，但也有 <function>chmod()</function>
	系統呼叫。  在這種情況，<command>man</command>
	應該要指定所要查詢的章節：</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>如此一來就會查 <command>chmod</command> 指令部分。
	通常在寫文件時會把有參考到某特定章節的 man 號碼也一併寫在括號內。
	所以 &man.chmod.1; 就是指 <command>chmod</command> 指令，而
	&man.chmod.2; 則是指系統呼叫的部分。</para>

      <para>如果您已經知道命令的名稱，只是不知道要怎樣使用的話，那就比較好辦。
	但若不知道要用哪個指令時，該怎麼辦呢？  這個時候，就可以利用
	<command>man</command> 的搜尋關鍵字功能，
	以在各說明的介紹部分搜尋相關字眼。，它的選項是 <option>-k</option>：
	</para>

      <screen>&prompt.user; <userinput>man -k mail</userinput></screen>

      <para>如此一來會看到一堆有 <quote>mail</quote> 關鍵字的說明，
	事實上該功能與 <command>apropos</command> 指令是一樣的。</para>

      <para>而有時你會看到像是 <filename>/usr/bin</filename>
	有許多看起來頗炫的指令，但不知其用途？  只要簡單輸入：</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

	<para>或者是</para>

	<screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

	<para>這兩者的指令效果是一樣的。</para>
    </sect2>

    <sect2 xml:id="basics-info">
      <title>GNU Info 檔案</title>
      <indexterm><primary>Free Software Foundation</primary></indexterm>

      <para>FreeBSD 有許多程式跟工具來自於自由軟體基金會(FSF)。  除了 man
	線上說明之外，這些程式提供了另外一種更具有彈性的 hypertext 格式文件，
	叫做 <literal>info</literal>。  可以用 <command>info</command>
	指令來閱讀，或者若有裝 <application>emacs</application> 亦可透過
	<application>emacs</application> 的 info 模式閱讀。</para>

      <para>要用 &man.info.1; 指令，只需打：</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>按 <literal>h</literal> 會有簡單說明，而若要快速查閱相關操作方式，
	則請按 <literal>?</literal>。</para>
    </sect2>
  </sect1>
</chapter>
